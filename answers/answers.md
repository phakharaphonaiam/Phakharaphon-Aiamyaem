# คำตอบแลบ Big-O Time & Space Complexity

> เติมเฉพาะ **คำตอบและเหตุผลของคุณ** สำหรับแต่ละข้อ (ดูโจทย์ใน `README.md`).  
> ให้ตอบเป็น Big-O ของ **เวลา (Worst-case)** และ **พื้นที่ช่วย (Auxiliary Space)** พร้อมเหตุผลย่อ

---

## ข้อมูลผู้ส่ง
- ชื่อ – นามสกุล:ภครพล เอี่ยมแย้ม
- รหัสนักศึกษา: 1670700432
- เซกชัน: 227D

## เช็กลิสต์ก่อนส่ง
- [ ] อ่านโจทย์ครบทุกข้อใน `README.md`
- [ ] คำตอบระบุ Big-O และเหตุผลย่อในแต่ละข้อ
- [ ] ไฟล์นี้ชื่อ `answers/answers.md` และถูก push ขึ้นรีโพแล้ว


## Problem 1 — Harmonic inner loop
**Time (worst-case):** `O(____)`  
**เหตุผลย่อ:**  
- ลูปนอกวิ่งตั้งแต่ i = 1 ถึง n สำหรับแต่ละ i, ลูปในขยับ j ทีละ i → ทำงาน ~ n/i ครั้ง รวมทั้งหมด = n(1 + 1/2 + 1/3 + ... + 1/n) ≈ n log n

**Auxiliary Space:** `O(____)`  
**เหตุผลย่อ:**  
- ใช้เพียงตัวแปร i, j และตัวแปรชั่วคราว ไม่มีโครงสร้างข้อมูลเพิ่มเติม

---

## Problem 2 — First duplicate ด้วยเซต
**Time (worst-case):** `O(n)` (สมมติว่า hash set เฉลี่ย O(1))  
**เหตุผลย่อ:** ต้องวนตรวจสมาชิกทุกตัวสูงสุด n ครั้ง และการเช็ก/เพิ่มในเซตใช้ O(1) เฉลี่ย → รวม O(n)

**Auxiliary Space:** `O(n)`  
**เหตุผลย่อ:** เซตเก็บสมาชิกที่เจอแล้วได้มากสุด n ตัว

**หากห้ามใช้หน่วยความจำเพิ่มเกิน O(1):**  
- วิธี/แนวคิด: เรียงลำดับอาร์เรย์ก่อน แล้วตรวจหาตัวซ้ำจากซ้ายไปขวา
- เวลาอย่างน้อยที่ต้องใช้: `O(n log n)` และเหตุผลย่อ: การ sort ที่ใช้ comparison มี lower bound O(n log n) และการตรวจเช็กใช้ O(n) รวมแล้ว O(n log n)

---

## Problem 3 — Fibonacci แบบเรียกซ้ำ (โดยไม่มี memoization)
**Time (worst-case):** `O(2^n)`  
**เหตุผลย่อ:**  ทุกครั้งเรียก fib(n-1) และ fib(n-2) → จำนวนการเรียกโตแบบ exponential

**Auxiliary Space (ความลึกสแตก):** `O(n)`  
**เหตุผลย่อ:**  ความลึกของการเรียก recursive สูงสุด n - stack ใช้ O(n)

> (ตัวเลือก) ถ้าใช้ **memoization/DP** เวลาและพื้นที่จะเป็นอย่างไร และเพราะเหตุใด?

เวลา: O(n) เพราะแต่ละค่า Fibonacci ถูกคำนวณครั้งเดียว
พื้นที่: O(n) สำหรับ memoization หรือ DP ปกติ, และ O(1) ถ้าใช้ bottom-up ที่ optimize
เพราะเหตุใด
ใน recursion ปกติ fib(n) จะเรียก fib(n-1) และ fib(n-2) ซ้ำ ๆ หลายครั้ง → จำนวนการเรียกพุ่งเป็น O(2^n) แต่ถ้าใช้ memoization (top-down) หรือ DP (bottom-up) จะเก็บค่าที่เคยคำนวณไว้แล้ว 
ดังนั้น แต่ละ fib(k) (k = 0..n) ถูกคำนวณ ครั้งเดียวเท่านั้น → รวมไม่เกิน n ครั้ง → O(n)

---

## Problem 4 — 3-Sum ด้วย sort + two pointers
**Time (worst-case):** `O(n²)`  
**เหตุผลย่อ:** การ sort ใช้ O(n log n) ลูปหลัก (fix i + two pointers) ใช้ O(n²) → dominate → รวม O(n²)

**Auxiliary Space:**  
- ถ้า sort **in-place** (เช่น heapsort): `O(1)` — เหตุผล: ใช้ตัวแปร index เท่านั้น
- ถ้า sort ต้องใช้บัฟเฟอร์ (เช่น mergesort/Timsort): `O(n)` — เหตุผล: ต้องใช้ buffer เก็บข้อมูลขณะ merge

---


## อ้างอิง/บันทึกเพิ่มเติม (ถ้ามี)
- ................................................................................
